# 第 4 章 表达式

## [1](1.cpp) | [2](2.cpp)

## 3

可以接受，因为这种行为是可控的。

## [4](4.cpp) | [5](5.cpp) | [6](6.cpp) | [7](7.cpp)

## 8

`&&` 当且仅当左侧为真时，才会对右侧求值。  
`||` 当且仅当左侧为假时，才会对右侧求值。  
`==` 没有标准约束（其求值顺序是未定义的）。

## 9

当 `cp` 不是 nullptr 时，判断 `cp` 所指向的内容是否为 0（本例中的 H）。

## [10](10.cpp) | [11](11.cpp)

## 12

先判断 j 是否小于 k，其结果非 0 即 1，再 0 或 1 和 i 做比较，看其是否相等。

## [13](13.cpp)

## 14

第一个无法执行，第二个为 `true`。

## 15

```C++
dval = ival = 0;
pi = 0;
```

## 16

a. `if (p = getPtr() != 0)` 等价于 `if (p = (getPtr() != 0))`，改为 `if ((p = getPtr()) != 0)`  
b. 会导致一直为 `true`，改为 `if (i == 1024)`

## 17

前置版本自增后作为左值返回，后置版本将其自增，并将原始值的副本作为右值返回。

## 18

将的得到的是从第二个元素开始的结果，但判断的仍是前一个元素的合法性，所以可能会发生越界。

## 19

a. `ptr` 不是 nullptr，并且 `ptr` 所指向的元素不为 0, 则条件为真，并且将 `ptr + 1` 指向后一个元素；若 `ptr` 是 nullptr，则后续操作均不会进行，且条件为假。

b. `ival` 本身不为 0，且 `ival + 1` 不是 0。  
显然这些结果是可以枚举的：`false` 的两种情况：
1. `val = -1` 前者成立，后者不成立。
2. `val = 0` 前者不成立。  
其余的情况均为 `ture`

## 20

a. `*iter++` 将自增并返回其自增前解引用（指向）的内容作为右值返回。  
b. `(*iter)++` 将其所指向的值自增并返回其自增前所指向的内容作为右值返回。  
c. `*iter.empty()` 不合法，`iterator` 没有 `empty()` 这个函数。  
d. `iter->empty()` 可以，查询所指向的字符串是否为空。  
e. `++*iter`，会先解引用后自增，即自增其指向的值，并返回自增后的左值。  
f. `iter++->empty()`，会优先执行成员选择，也就是判断所指向的值是否为空，并返回一个右值，随后将指针自身自增。

## [21](21.cpp) | [22](22.cpp) | [23](23.cpp)

## 24

等价于 `finalgrade = ((grade > 90) ? "high pass" : (grade < 60)) ? "fail" : "pass";` 若大于 90 优先执行括号会返回 `"high pass"`，其作为布尔值始终为真，因此会产生一个错误。

## 25

按照优先级，会先取反再左移，注意到取反的时候就是 int 了，即 `11111111111111111111111110001110`，后左移得 `11111111111111111110001110000000`，其对应的十进制结果为 -7296。

## 26

标准限定最小 16 位，不够 27 位。（现在一般实现是 4 个字节，也就是 32 位的）所以其结果是不确定的。

## 27

a. 3  
b. 7  
c. 1  
d. 1  

## [28](28.cpp) | [29](29.cpp)

## 30

a. `sizeof x + y` 等价于 `(sizeof x) + y`  
b. `sizeof p->mem[i]` 等价于 `sizeof (p->mem[i])`  
c. `sizeof a < b` 等价于 `(sizeof a) < b`  
d. `sizeof f()` 等价于 `sizeof (f())`

## 31

能用前置版本就用前置版本，减少额外的附加操作。

```C++
for(vector<int>::size_type ix = 0; ix != ivec.size(); ++ix, --cnt)
    ivec[ix] = cnt;
```

## 32

遍历数组的元素，同时提供一个从 0 开始的自增变量（也可以用于下标遍历）。

## 33

~~`someValue` 为真时，将 `x` `y` 分别自增后，返回自增后的 `y`  
`someValue` 为假时，将 `x` `y` 分别自减后，返回自减后的 `y`~~

根据优先级，其等价于 `(someValue ? ++x, ++y: --x), --y`  
也就是 `someValue ? (++x, y) : (--x, --y)`  
则 `someValue` 为真时自增 `x` 同时返回 `y`  
`someValue` 为假时自减 `x` 和 `y` 并返回自减后的 `y`。

## 34

a. 转换为 `bool`。  
b. `iavl` 转换成 `float` 相加后转换为 `double`。
c. `cval` 转换沉 `int` 同 `ival` 相乘。 

## 35

a. `'a'` 被转化成整型和 `3` 相加后转换成 `char` 型赋给 `cval`。  
b. `ival` 被转化成 `double` 同 `1.0` 相乘，`ui` 也被转化成 `double` 相减后被转换成 `float`。  
c. `ui` 转换成 `float` 同 `fval` 相乘，结果转换为 `double`。  
d. `ival` 被转换成 `float` 相加后被转换成 `double` 再相加，最后被截断成 `char`。

## 36

```C++
i *= d;
i *= static_cast<int>(d);
```

## 37
```C++
a. pv = static_cast<void *>(const_cast<string *>(ps));  
b. i = static_cast<int>(*pc);  
c. pv = static_cast<void *>(&d);
d. pc = static_cast<char *>(pv)
```

## 38

相除的结果应该是一个 `int` 值，随后被 cast 成 `double`，并赋给了 `slope`。